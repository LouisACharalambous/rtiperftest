/*
 * (c) 2005-2017  Copyright, Real-Time Innovations, Inc. All rights reserved.
 * Subject to Eclipse Public License v1.0; see LICENSE.md for details.
 */

#ifdef RTI_CUSTOM_TYPE
#include "custom.idl"
#endif

const long MAX_SYNCHRONOUS_SIZE = 63000;
const long MAX_BOUNDED_SEQ_SIZE = 63000;
#ifndef RTI_FLATDATA_MAX_SIZE
  const long RTI_FLATDATA_MAX_SIZE = 10485760; // 10MB
#endif
const long MAX_PERFTEST_SAMPLE_SIZE = 2147482620; // 2GB-1KB-4B (RTI_CDR_MAX_SERIALIZED_SIZE)
const long MAX_CFT_VALUE = 65535;
const long KEY_SIZE = 4;
const unsigned long DEFAULT_THROUGHPUT_BATCH_SIZE = 8192; // 8kB

/*
 * Topic Names for the different channel RTI Perftest will use
 */
const string THROUGHPUT_TOPIC_NAME = "Throughput";
const string LATENCY_TOPIC_NAME = "Latency";
const string ANNOUNCEMENT_TOPIC_NAME = "Announcement";

/*
 * This idl uses prefix annotations. In order to compile with previous versions
 * of *Connext DDS Professional* modify the following annotations:
 *
 * - @final -- Remove it and replace at the
 *             end with "//@Extensibility FINAL_EXTENSIBILITY"
 * - @key   -- Remove it and replace it at the end of the member with "//@key"
 *
 */

@final
struct TestData_t {
    octet key[KEY_SIZE];

    long entity_id;
    unsigned long seq_num;
    long timestamp_sec;
    unsigned long timestamp_usec;
    long latency_ping;
    sequence<octet, MAX_BOUNDED_SEQ_SIZE> bin_data;
  #ifdef RTI_CUSTOM_TYPE
    RTI_CUSTOM_TYPE custom_type;
    // custom_type_size is the serialize size of the field custom_type
    // in the the sample that we send on the wire
    long custom_type_size;
  #endif

};

@final
struct TestDataKeyed_t {
    @key
    octet key[KEY_SIZE];

    long entity_id;
    unsigned long seq_num;
    long timestamp_sec;
    unsigned long timestamp_usec;
    long latency_ping;
    sequence<octet, MAX_BOUNDED_SEQ_SIZE> bin_data;
  #ifdef RTI_CUSTOM_TYPE
    @key
    RTI_CUSTOM_TYPE custom_type;
    long custom_type_size;
  #endif
};

@final
struct TestDataLarge_t {
    octet key[KEY_SIZE];

    long entity_id;
    unsigned long seq_num;
    long timestamp_sec;
    unsigned long timestamp_usec;
    long latency_ping;
    sequence<octet> bin_data;
  #ifdef RTI_CUSTOM_TYPE
    RTI_CUSTOM_TYPE custom_type;
    long custom_type_size;
  #endif
};

@final
struct TestDataKeyedLarge_t {
    @key
    octet key[KEY_SIZE];

    long entity_id;
    unsigned long seq_num;
    long timestamp_sec;
    unsigned long timestamp_usec;
    long latency_ping;
    sequence<octet> bin_data;
  #ifdef RTI_CUSTOM_TYPE
    @key
    RTI_CUSTOM_TYPE custom_type;
    long custom_type_size;
  #endif
};

/********************************** FLATDATA **********************************/
#ifdef RTI_FLATDATA_AVAILABLE

@mutable
@language_binding(FLAT_DATA)
struct TestData_FlatData_t {
    octet key[KEY_SIZE];

    long entity_id;
    unsigned long seq_num;
    long timestamp_sec;
    unsigned long timestamp_usec;
    long latency_ping;
    sequence<octet, MAX_BOUNDED_SEQ_SIZE> bin_data;
  #ifdef RTI_CUSTOM_TYPE_FLATDATA
    RTI_CUSTOM_TYPE_FLATDATA custom_type;
    // custom_type_size is the serialize size of the field custom_type
    // in the the sample that we send on the wire
    long custom_type_size;
  #endif
};

@mutable
@language_binding(FLAT_DATA)
struct TestDataKeyed_FlatData_t {
    @key
    octet key[KEY_SIZE];

    long entity_id;
    unsigned long seq_num;
    long timestamp_sec;
    unsigned long timestamp_usec;
    long latency_ping;
    sequence<octet, MAX_BOUNDED_SEQ_SIZE> bin_data;
  #ifdef RTI_CUSTOM_TYPE_FLATDATA
    @key
    RTI_CUSTOM_TYPE_FLATDATA custom_type;
    long custom_type_size;
  #endif
};

@mutable
@language_binding(FLAT_DATA)
struct TestDataLarge_FlatData_t {
    octet key[KEY_SIZE];

    long entity_id;
    unsigned long seq_num;
    long timestamp_sec;
    unsigned long timestamp_usec;
    long latency_ping;
    sequence<octet, RTI_FLATDATA_MAX_SIZE> bin_data;
  #ifdef RTI_CUSTOM_TYPE_FLATDATA
    RTI_CUSTOM_TYPE_FLATDATA custom_type;
    long custom_type_size;
  #endif
};

@mutable
@language_binding(FLAT_DATA)
struct TestDataKeyedLarge_FlatData_t {
    @key
    octet key[KEY_SIZE];

    long entity_id;
    unsigned long seq_num;
    long timestamp_sec;
    unsigned long timestamp_usec;
    long latency_ping;
    sequence<octet, RTI_FLATDATA_MAX_SIZE> bin_data;
  #ifdef RTI_CUSTOM_TYPE_FLATDATA
    @key
    RTI_CUSTOM_TYPE_FLATDATA custom_type;
    long custom_type_size;
  #endif
};

#endif // RTI_FLATDATA_AVAILABLE

// Generate this type in order to propagate information about rti perftest when
// using output = dds
struct perftestThroughputInfo {
    @key long subId;
    @optional unsigned long long packets;
    @optional unsigned long long packetsS;
    @optional double packetsAve;
    @optional double mbps;
    @optional double mbpsAve;
    @optional unsigned long long lost;
    @optional float lostPercent;
};
struct perftestLatencyInfo {
    @key long pubId;
    @optional unsigned long long latency;
    @optional double ave;
    @optional double std;
    @optional unsigned long long min;
    @optional unsigned long long max;
    @optional unsigned long long h50;
    @optional unsigned long long h90;
    @optional unsigned long long h99;
    @optional unsigned long long h9999;
    @optional unsigned long long h999999;
    @optional double serialize;
    @optional double deserialize;
    @optional double total;
};

struct perftestInfo {
    @key unsigned long dataLength;
    @optional perftestLatencyInfo pLatencyInfo;
    @optional perftestThroughputInfo pThroughputInfo;
    @optional double outputCpu;
};